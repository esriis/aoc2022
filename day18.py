# -*- coding: utf-8 -*-
"""day18.ipynb

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1qEWnwVznpIZcqnfzWPQvUzO8dTDa9zxK
"""

import numpy as np

path = "input/day18.txt"
with open(path, mode="r") as f:
    text=f.read()

def parse_line(line: str) -> np.ndarray:
    return np.array([int(num) for num in line.split(",")])

cubes = [parse_line(line) for line in text.splitlines()]

surface=6*len(cubes)

def get_covered_sides(cubes, index):
    rest = [(index+1)%3, (index+2)%3]
    cs = sorted(cubes, key=lambda x: (x[rest[0]], x[rest[1]], x[index]))
    covered=0
    for i in range(len(cubes)-1):
        if (
            (np.sum(cs[i+1][rest]-cs[i][rest]) == 0)
            and (cs[i+1][index] - cs[i][index] == 1)
        ):
            covered+=2
    return covered

covered=0
for index in range(3):
    covered += get_covered_sides(cubes, index)

solution_part1 = surface-covered
print(f"Solution to part 1: {solution_part1}")

"""Part 2"""

min_vals = [
    min(cube[i] for cube in cubes)
    for i in [0, 1, 2]
]
max_vals = [
    max(cube[i] for cube in cubes)
    for i in [0, 1, 2]
]

space = np.zeros([i+1 for i in max_vals])
for cube in cubes:
    space[tuple(cube)] = 1

def get_neighbors(pos: np.ndarray, space: np.ndarray):
    poss = [
        pos+step
        for step in [
            (0,0,1),
            (0,0,-1),
            (0,1,0),
            (0,-1,0),
            (1,0,0),
            (-1,0,0)
        ]
    ]
    for p in poss:
        if all(
            p[i] in range(space.shape[i])
            for i in [0,1,2]
        ):
            if space[tuple(p)]==0:
                space[tuple(p)]=2
    space[tuple(pos)]=1
    return space

edges=[
    np.array([0,y,z])
    for y in range(space.shape[1])
    for z in range(space.shape[2])
] + [
    np.array([space.shape[0]-1,y,z])
    for y in range(space.shape[1])
    for z in range(space.shape[2])
] + [
    np.array([x,0,z])
    for x in range(space.shape[0])
    for z in range(space.shape[2])
] + [
    np.array([x,space.shape[1]-1,z])
    for x in range(space.shape[0])
    for z in range(space.shape[2])
] + [
    np.array([x,y,0])
    for x in range(space.shape[0])
    for y in range(space.shape[1])
] + [
    np.array([x,y,space.shape[2]-1])
    for x in range(space.shape[0])
    for y in range(space.shape[1])
]

for edge in edges:
    if space[tuple(edge)]==0:
        space=get_neighbors(edge, space)
        coordinates = np.where(space==2)
        iter=0
        while len(coordinates[0])> 0:
            iter+=1
            for i in range(len(coordinates[0])):
                pos = np.array([
                    coordinates[j][i] for j in [0,1,2]
                ])
                space=get_neighbors(pos, space)
            coordinates = np.where(space==2)

anti = 1-space
antis = [
    np.array([x,y,z])
    for x in range(anti.shape[0])
    for y in range(anti.shape[1]) for z in range(anti.shape[2])    if anti[x,y,z] == 1
]
surface2=6*len(antis)


covered2=0
for index in range(3):
    covered2 += get_covered_sides(antis, index)

solution_part2 = solution_part1-(surface2-covered2)

print(f"Solution to part 2: {solution_part2}")
